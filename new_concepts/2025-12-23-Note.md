오늘 두 동기생의 대화를 몰래 염탐하다가 너무나도 수준이 높은 대화여서 염탐한 보람이 하나도 없었다. 마치 나루토와 사스케의 대전을 구경하는 록리의 기분을 느꼈다. 

하지만 모른다고 그냥 와 대단하다 하고 넘어가면 안되기에 오늘 몰래 들어본 개념을 정리해본다. 

일단 필자는 초등학교를 2학년 떄 자퇴한 화려한 학력이기에 맞춤법 오류와 부족한 필력은 양해를 부탁한다. 

---
### 대화의 내용은 이러했다. 

## 동기 A: 
B님의 저번 프로젝트 팀원이 프로젝트 구조를 가져와서 보여줬는데 이해가 되지 않는 점이 몇 가지 있습니다. 혹시 설명 가능할까요?
- 왜 스토리지가 밖으로 혼자 따로 나와있나요?
- 어째서 Domain이 존재하는데 Service 클래스에서 API의 DTO를 직접 접근하나요? 
  - 보통은 응답요청 dto를 사용하는데 왜 이런 방식을 사용하셨나요?
  - 해당 방식으로 하면 레이어 분리가 무너지지 않나요?
- 혹시 버전 관리도 염두하시고 v1등을 이름에 사용하셨나요?

## 동기 B: 
사실 처음에는 제가 생각했던 흐름은 해당과 같았습니다.

Controller <--- dto ---> Service <---- domain ----> Repository <----- Entity ----> db

전 원래 pojo를 활용하여 entity와 domain에서 사용하는 것을 분리하는 형태를 생각해서 서비스 내부에 dto가 있었습니다.

하지만 저희 프로젝트의 규모가 작다보니, 이러한 식의 분리는 오히려 복잡함만 늘리고 실용성이 떨어지기에, 현재 보고 계신 형태로 축약했습니다. 

## 동기 A: 
아 그렇군요. 완벽히 이해 했습니다. 왜 실무처럼 진행한 흔적이 보이다가 갑자기 규모가 작아졌는지 이해했습니다. 답변 감사합니다. 

## 나: 
???

---

나의 의문은 이러했다. 
1. Service에서 원래 DTO를 받는게 맞지 않나? 
2. Domain은 그냥 각각의 기능들을 의미하는 거 아닌가? 근데 그게 왜 dto를 직접 접근하는것에 대한 문제가 되지?
3. pojo가 뭔데?
4. 만약 처음 생각한 구조가 실무에서 사용되는 구조라면 규모가 작아졌다고 왜 구조를 변경했는가?

처음에는 뭐가 뭔지를 몰라서 30분 정도 난 뭘 모르는가 고민했다. 그리고 해당 질문들로 모르는 점들을 정리했다. 

이후 LLM들과 열심히 키보드 배틀을 하면서 해당 답변을 얻었다. 순서대로 질문을 답해보자. 
## 1. Service에서 원래 DTO를 받는게 맞지 않나?

사실 난 처음에는 비즈니스 로직은 Service 클래스가 담당하는 걸로 알았다. 그렇기에 당연히 직접 DTO를 받고, 해당 DTO를 통해서 DB에서 entity를 꺼내오는 걸로 생각을 했다. 

하지만 실제로 service는 비즈니스 로직의 실행을 담당한다. 그럼 실제 로직은 어디 있는가? 이에 대한 답변은 다음 질문으로 이어진다. 


## 2. Domain은 그냥 각각의 기능들을 의미하는 거 아닌가? 근데 그게 왜 dto를 직접 접근하는것에 대한 문제가 되지?

Domain 이란 무엇인가?
Domain은 영어로는 영역이란 의미가 있다. 한동한 인터넷을 강타한 영연전개가 영어로는 domain expansion이다.
하지만 안타깝게도 개발자에게 영연전개는 불가능하기에, 개발자가 사용하는 domain은 다른 의미가 있다. 

1. 한 프로그램에서 다양한 기능들을 각각 domain이라고 칭하기도 한다.
2. 또한 domain은 웹앱에서 비즈니스 로직을 담당하는 클래스를 의미하기도 한다. 

사실 처음 이 대화를 본 난 머리속에 우주가 펼쳐졌다. 개발자는 영연전개를 사용할 수 없다고 했는데 그 순간 무량공처를 맞은 거 마냥 사고가 마비되는 기분이었다. 

각설하고 이렇게 domain은 실제로 비즈니스 로직을 담당하는 클래스이기에, service는 그저 값을 받고 domain에 보내줄 뿐 직접 요청하고 접근할 필요는 없다.

근데 왜 굳이 domain과 service의 역할을 분리하는가? 이 문제는 개발자의 숙적인 코드 반복으로 인한 유지 보수의 어려움, 그리고 가독성의 문제 때문이다. 
예시로, 구매 기능이 있는 프로그램을 개발을 하고 있는데, 회원의 등급마다 할인률이 다를 경우, 회원의 등급을 확인하는 코드가 필요하다. 그리고 다양한 경우의 수에 따라서
할인을 얾마나 해줄지 달라진다. 하지만 할이은 환불할때도 할인이 얼마나 들어갔는지 확인을 해야하고, 장바구니에 담을때도 할인률이 얼마인지 알아야한다. 그렇다면 각각의 서비스에 모두 회원 등급을 
검색을 해야한다. 
하지만 이걸 domain이라는 한 클래스에 모두 모아둔다면, 각각의 서비스는 domain클래스를 불러오기만 하면 되고, 코드 수정시 domain만 수정하면 된다.
또한 domain 내부에서는 비즈니스 로직을 다양한 메소드로 나눠서 정리하는 것 또한 가능하다.

## 3. pojo가 뭔데?
POJO는 Plain Old Java Object의 약어다. 영어로 단순한 자바 객체라는 의미인데 말 그대로 단순한 자바 객체이다. 
이 단순한 자바 객체를 사용하는 이유는 DTO나 Entity는 JPA나 DB에게 의존을 하기에 테스트트 짜거나 이를 활용해 메소드를 실행한다면 복잡성이 올라간다. 하지만 POJO를 사용한다면
단순 자바이기에 코드를 작성할 때 매우 간편하다. 
이런 장점이 있는 POJO이기에, 처음에 리퀘스트DTO를 받으면, 해당 DTO를 통해 entity에 접근하고, entity의 값을 읽어서, 해당 값을 가진 POJO를 생성한다. 생성된 POJO를 domain에 넘겨주면
이제 필요한 값은 전부 단순 자바 객체로 넘겨줘서 실행시 DB나 서버가 필요가 없다. 

4. 만약 처음 생각한 구조가 실무에서 사용되는 구조라면 규모가 작아졌다고 왜 구조를 변경했는가?
동기 B는 처음부터 이러한 pojo와 domain을 활용하는 구조를 사용해서 커플링을 줄이고 유지보수도 쉬워질 수 있었는데 어째서 이런 구조를 포기했는가?
답은 프로젝트의 규모가 크지 않기에, domain을 따로 사용할 만큼 비즈니스 로직이 복잡하지 않고, 굳이 과도한 레이어 분리를 해서 복잡성을 늘릴 필요가 없어서이다. 
단순 CRUD를 실행하는 경우에는 더 빠른 개발을 위해, 더 간소화한 구조를 선택하는 것 또한 정답이다.

---

## 번외편

사실 LLM들을 3시간 정도 괴롭히다 보니 또 다른 의문이 생겼다. 근데 이 DTO는 어디서 갑자기 튀어나오는걸까? 왜 우리는 서비스에서 DTO를 반환하지? 내가 아는 DTO는 분명 entity를 직접 주고 받으면
정보가 노출될 가능성이 있어서 사용하는건데, 처음부터 날라오는 이 DTO는 어디서 탄생했단 말인가?
답은 Spring의 Jackson모듈이었다. Springboot 내부에는 잭슨이라는 모듈이 존재하는데 해당 모듈은 클리아언트가 보내는 리퀘스트를 json에서 dto로 변환을 해준다. 그리고 이 변환된 dto를 통해 우리는
토큰 인증 후 비즈니스 로직을 실행하는 것이었다. 
그렇다면 반환은 왜 하는가? 
이 또한 우리의 친구 잭슨이 클라이언트는 json밖에 모르기에, 우리의 dto를 리퀘스트를 받았을때 처럼, 자동으로 json으로 반환해주기 위해서였다. 클라이언트는 json을 받고, 갱신된 정보를
화면에 띄우는 것이다. 이러한 양방형 연결이 클라이언트가 행동을 하면 그에 맞춰서 새로운 정보를 보여줄 수 있는 구조였다. 

다음에도 세계자 최강자들의 전투를 구경할 기회가 생기면 다시 정리글을 올려야겠다. 아키텍처는 참 어렵다. 흑흑